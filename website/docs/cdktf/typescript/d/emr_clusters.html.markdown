---
subcategory: "E-MapReduce (EMR)"
layout: "alicloud"
page_title: "Alicloud: alicloud_emr_clusters"
sidebar_current: "docs-alicloud-datasource-emr-clusters"
description: |-
  Provides a list of Emr Clusters to the user.
---


<!-- Please do not edit this file, it is generated. -->
# alicloud\_emr\_clusters

This data source provides the Emr Clusters of the current Alibaba Cloud user.

-> **DEPRECATED:**  This datasource has been deprecated from version `12040`. Please use new datasource [emrv2_clusters](https://registry.terraform.io/providers/aliyun/alicloud/latest/docs/data-sources/emrv2_clusters).

-> **NOTE:** Available in v1.146.0+.

## Example Usage

Basic Usage

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as alicloud from "./.gen/providers/alicloud";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    /*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
    You can read more about this at https://cdk.tf/variables*/
    const name = new cdktf.TerraformVariable(this, "name", {
      default: "tf-testAccClusters",
    });
    const alicloudRamRoleDefault = new alicloud.ramRole.RamRole(
      this,
      "default",
      {
        description: "this is a role test.",
        document:
          '    {\n        "Statement": [\n        {\n            "Action": "sts:AssumeRole",\n            "Effect": "Allow",\n            "Principal": {\n            "Service": [\n                "emr.aliyuncs.com",\n                "ecs.aliyuncs.com"\n            ]\n            }\n        }\n        ],\n        "Version": "1"\n    }\n',
        force: true,
        name: name.stringValue,
      }
    );
    const dataAlicloudEmrClustersIds =
      new alicloud.dataAlicloudEmrClusters.DataAlicloudEmrClusters(
        this,
        "ids",
        {}
      );
    const dataAlicloudEmrMainVersionsDefault =
      new alicloud.dataAlicloudEmrMainVersions.DataAlicloudEmrMainVersions(
        this,
        "default_3",
        {}
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAlicloudEmrMainVersionsDefault.overrideLogicalId("default");
    const dataAlicloudResourceManagerResourceGroupsDefault =
      new alicloud.dataAlicloudResourceManagerResourceGroups.DataAlicloudResourceManagerResourceGroups(
        this,
        "default_4",
        {
          status: "OK",
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAlicloudResourceManagerResourceGroupsDefault.overrideLogicalId(
      "default"
    );
    const dataAlicloudVpcsDefault =
      new alicloud.dataAlicloudVpcs.DataAlicloudVpcs(this, "default_5", {
        nameRegex: "default-NODELETING",
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAlicloudVpcsDefault.overrideLogicalId("default");
    new cdktf.TerraformOutput(this, "emr_cluster_id_1", {
      value: cdktf.propertyAccess(dataAlicloudEmrClustersIds.clusters, [
        "0",
        "id",
      ]),
    });
    const alicloudSecurityGroupDefault =
      new alicloud.securityGroup.SecurityGroup(this, "default_7", {
        name: name.stringValue,
        vpcId: cdktf.Token.asString(
          cdktf.propertyAccess(dataAlicloudVpcsDefault.ids, ["0"])
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    alicloudSecurityGroupDefault.overrideLogicalId("default");
    const dataAlicloudEmrInstanceTypesDefault =
      new alicloud.dataAlicloudEmrInstanceTypes.DataAlicloudEmrInstanceTypes(
        this,
        "default_8",
        {
          clusterType: cdktf.Token.asString(
            cdktf.propertyAccess(
              dataAlicloudEmrMainVersionsDefault.mainVersions,
              ["0", "cluster_types", "0"]
            )
          ),
          destinationResource: "InstanceType",
          instanceChargeType: "PostPaid",
          supportLocalStorage: false,
          supportNodeType: ["MASTER", "CORE", "TASK"],
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAlicloudEmrInstanceTypesDefault.overrideLogicalId("default");
    const dataAlicloudVswitchesDefault =
      new alicloud.dataAlicloudVswitches.DataAlicloudVswitches(
        this,
        "default_9",
        {
          vpcId: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudVpcsDefault.ids, ["0"])
          ),
          zoneId: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
              "0",
              "zone_id",
            ])
          ),
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    dataAlicloudVswitchesDefault.overrideLogicalId("default");
    const dataAlicloudEmrDiskTypesDataDisk =
      new alicloud.dataAlicloudEmrDiskTypes.DataAlicloudEmrDiskTypes(
        this,
        "data_disk",
        {
          clusterType: cdktf.Token.asString(
            cdktf.propertyAccess(
              dataAlicloudEmrMainVersionsDefault.mainVersions,
              ["0", "cluster_types", "0"]
            )
          ),
          destinationResource: "DataDisk",
          instanceChargeType: "PostPaid",
          instanceType: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
              "0",
              "id",
            ])
          ),
          zoneId: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
              "0",
              "zone_id",
            ])
          ),
        }
      );
    const dataAlicloudEmrDiskTypesSystemDisk =
      new alicloud.dataAlicloudEmrDiskTypes.DataAlicloudEmrDiskTypes(
        this,
        "system_disk",
        {
          clusterType: cdktf.Token.asString(
            cdktf.propertyAccess(
              dataAlicloudEmrMainVersionsDefault.mainVersions,
              ["0", "cluster_types", "0"]
            )
          ),
          destinationResource: "SystemDisk",
          instanceChargeType: "PostPaid",
          instanceType: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
              "0",
              "id",
            ])
          ),
          zoneId: cdktf.Token.asString(
            cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
              "0",
              "zone_id",
            ])
          ),
        }
      );
    const alicloudEmrClusterDefault = new alicloud.emrCluster.EmrCluster(
      this,
      "default_12",
      {
        chargeType: "PostPaid",
        clusterType: cdktf.Token.asString(
          cdktf.propertyAccess(
            dataAlicloudEmrMainVersionsDefault.mainVersions,
            ["0", "cluster_types", "0"]
          )
        ),
        emrVer: cdktf.Token.asString(
          cdktf.propertyAccess(
            dataAlicloudEmrMainVersionsDefault.mainVersions,
            ["0", "emr_version"]
          )
        ),
        highAvailabilityEnable: true,
        hostGroup: [
          {
            diskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                    "0",
                    "min",
                  ]),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            diskCount: "1",
            diskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                "0",
                "value",
              ])
            ),
            hostGroupName: "master_group",
            hostGroupType: "MASTER",
            instanceType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
                "0",
                "id",
              ])
            ),
            nodeCount: "2",
            sysDiskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(
                    dataAlicloudEmrDiskTypesSystemDisk.types,
                    ["0", "min"]
                  ),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            sysDiskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                "0",
                "value",
              ])
            ),
          },
          {
            diskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                    "0",
                    "min",
                  ]),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            diskCount: "4",
            diskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                "0",
                "value",
              ])
            ),
            hostGroupName: "core_group",
            hostGroupType: "CORE",
            instanceType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
                "0",
                "id",
              ])
            ),
            nodeCount: "3",
            sysDiskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(
                    dataAlicloudEmrDiskTypesSystemDisk.types,
                    ["0", "min"]
                  ),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            sysDiskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                "0",
                "value",
              ])
            ),
          },
          {
            diskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                    "0",
                    "min",
                  ]),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            diskCount: "4",
            diskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesDataDisk.types, [
                "0",
                "value",
              ])
            ),
            hostGroupName: "task_group",
            hostGroupType: "TASK",
            instanceType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
                "0",
                "id",
              ])
            ),
            nodeCount: "2",
            sysDiskCapacity: cdktf.Token.asString(
              cdktf.conditional(
                cdktf.Op.gt(
                  cdktf.propertyAccess(
                    dataAlicloudEmrDiskTypesSystemDisk.types,
                    ["0", "min"]
                  ),
                  160
                ),
                cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                  "0",
                  "min",
                ]),
                160
              )
            ),
            sysDiskType: cdktf.Token.asString(
              cdktf.propertyAccess(dataAlicloudEmrDiskTypesSystemDisk.types, [
                "0",
                "value",
              ])
            ),
          },
        ],
        isOpenPublicIp: true,
        masterPwd: "ABCtest1234!",
        name: name.stringValue,
        securityGroupId: cdktf.Token.asString(alicloudSecurityGroupDefault.id),
        sshEnable: true,
        tags: {
          Created: "TF",
          For: "acceptance test",
        },
        userDefinedEmrEcsRole: cdktf.Token.asString(
          alicloudRamRoleDefault.name
        ),
        vswitchId: cdktf.Token.asString(
          cdktf.propertyAccess(dataAlicloudVswitchesDefault.ids, ["0"])
        ),
        zoneId: cdktf.Token.asString(
          cdktf.propertyAccess(dataAlicloudEmrInstanceTypesDefault.types, [
            "0",
            "zone_id",
          ])
        ),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    alicloudEmrClusterDefault.overrideLogicalId("default");
    const dataAlicloudEmrClustersNameRegex =
      new alicloud.dataAlicloudEmrClusters.DataAlicloudEmrClusters(
        this,
        "nameRegex",
        {
          nameRegex: cdktf.Token.asString(alicloudEmrClusterDefault.name),
        }
      );
    new cdktf.TerraformOutput(this, "emr_cluster_id_2", {
      value: cdktf.propertyAccess(dataAlicloudEmrClustersNameRegex.clusters, [
        "0",
        "id",
      ]),
    });
  }
}

```

## Argument Reference

The following arguments are supported:

* `clusterName` - (Optional, ForceNew) The cluster name.
* `clusterTypeList` - (Optional, ForceNew) The cluster type list.
* `createType` - (Optional, ForceNew) How to create a cluster. Valid values: `onDemand`, `manual`.
* `defaultStatus` - (Optional, ForceNew) The default status.
* `depositType` - (Optional, ForceNew) The hosting type of the cluster. Valid values: `halfManaged`, `managed`.
* `enableDetails` - (Optional) Default to `false`. Set it to `true` can output more details about resource attributes.
* `ids` - (Optional, ForceNew, Computed)  A list of Cluster IDs.
* `isDesc` - (Optional, ForceNew) The is desc.
* `machineType` - (Optional, ForceNew) The host type of the cluster. The default is ECS. Valid values: `docker`, `ecs`, `pyhsicalMachine`, `ecsFromEcmHostpool`.
* `nameRegex` - (Optional, ForceNew) A regex string to filter results by Cluster name.
* `outputFile` - (Optional) File name where to save data source results (after running `terraform plan`).
* `resourceGroupId` - (Optional, ForceNew) The Resource Group ID.
* `statusList` - (Optional, ForceNew) The status list. Valid values: `abnormal`, `createFailed`, `creating`, `idle`, `released`, `releaseFailed`, `releasing`, `running`, `waitForPay`.
* `vpcId` - (Optional, ForceNew) The VPC ID.

## Argument Reference

The following attributes are exported in addition to the arguments listed above:

* `names` - A list of Cluster names.
* `clusters` - A list of Emr Clusters. Each element contains the following attributes:
	* `accessInfo` - Cluster connection information.
	  * `zkLinks` - Link address information list of ZooKeeper.
			* `link` - The access link address of ZooKeeper.
			* `port` - The port of ZooKeeper.
	* `autoScalingAllowed` - Whether flexible expansion is allowed.
	* `autoScalingByLoadAllowed` - Whether to allow expansion by load.
	* `autoScalingEnable` - Whether to enable elastic expansion.
	* `autoScalingSpotWithLimitAllowed` - Whether to allow the use of elastic scaling bidding instances.
	* `bootstrapActionList` - List of boot actions.
		* `name` - The name of the boot operation.
		* `path` - Boot operation script path.
		* `arg` - Parameters of the boot operation.
	* `bootstrapFailed` - The result of the boot operation.
	* `clusterId` - The first ID of the resource.
	* `clusterName` - The ClusterName.
	* `createResource` - Cluster tag, no need to pay attention.
	* `createTime` - The creation time of the resource.
	* `createType` - How to create a cluster.
	* `depositType` - The hosting type of the cluster.
	* `easEnable` - High security cluster.
	* `expiredTime` - The expiration time of the cluster.
	* `extraInfo` - Additional information for Stack.
	* `highAvailabilityEnable` - High availability cluster.
	* `hostGroupList` - List of cluster machine groups.
		* `hostGroupName` - The name of the machine group.
		* `instanceType` - Machine Group instance.
		* `nodes` - Machine node.
			* `createTime` - Creation time.
			* `diskInfos` - Disk information.
				* `device` - The disk name.
				* `diskId` - The ID of the disk.
				* `diskName` - The disk name.
				* `size` - Disk capacity.
				* `type` - Disk type.
			* `expiredTime` - Timeout time.
			* `innerIp` - The Intranet IP of the EMR.
			* `emrExpiredTime` - The timeout of the EMR.
			* `instanceId` - The ID of the ECS instance.
			* `pubIp` - Public IP address.
			* `status` - Status.
			* `supportIpv6` - Whether IPV6 is supported.
			* `zoneId` - The zone ID.
		* `bandWidth` - Bandwidth.
		* `diskCapacity` - Data disk capacity.
		* `diskCount` - The number of data disks.
		* `diskType` - System disk type:
		* `memoryCapacity` - Memory size.
		* `nodeCount` - The number of machine group nodes.
		* `period` - Package year and month time (days).
		* `chargeType` - Payment Type.
		* `cpuCore` - The number of CPU cores.
		* `hostGroupChangeType` - The current operation type of the machine Group:
		* `hostGroupId` - The ID of the machine group.
		* `hostGroupType` - Role of host in cluster:
	* `hostPoolInfo` - Machine pool information.
		* `hpBizId` - Machine pool ID.
		* `hpName` - The name of the machine pool.
	* `imageId` - The ID of the image used to create the cluster.
	* `localMetaDb` - Whether to use Hive local Metabase.
	* `machineType` - The host type of the cluster. The default is ECS.
	* `metaStoreType` - Metadata type:
	* `netType` - Cluster network type.
	* `paymentType` - The payment type of the resource.
	* `period` - The package year and month time of the machine group. The Valid Values : `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `12`, `24`, `36`.
	* `relateClusterInfo` - The information of the primary cluster associated with the Gateway.
		* `clusterId` - The ID of the associated cluster.
		* `clusterName` - The name of the associated cluster.
		* `clusterType` - The cluster type of the associated cluster.
		* `status` - The status  of the associated cluster.
	* `resizeDiskEnable` - Whether to allow disk expansion:
	* `runningTime` - The time (in seconds) that has been running.
	* `securityGroupId` - The ID of the security group.
	* `securityGroupName` - The name of the security group.
	* `softwareInfo` - Service list.
		* `clusterType` - Cluster type:
		* `emrVer` - E-MapReduce version number.
		* `softwares` - Service list.
			* `displayName` - The name of the service.
			* `name` - The internal name of the service.
			* `onlyDisplay` - Whether it shows.
			* `startTpe` - Startup type.
			* `version` - Service version.
	* `startTime` - Cluster startup time.
	* `status` - The cluster status.
	* `stopTime` - Cluster stop time.
	* `tags` - A mapping of tags to assign to the resource.
	* `userDefinedEmrEcsRole` - The EMR permission name used.
	* `userId` - The user ID.
	* `vpcId` - The VPC ID.
	* `vswitchId` - The vswitch id.
	* `zoneId` - The zone ID.
<!-- cache-key: cdktf-0.17.0-pre.15 input-45d9e1838ec05e010c39963c9b853d74334beccc3d25375af9f67b1eed2c06bc -->